#!/usr/bin/env ruby
# mercurial

# 20260125
# 0.9.0

# Changes since 0.8:
# -/0: Add robust VPN interface cleanup with lock-based concurrency control; improve error handling via dont_raise; add usage output; track VPN state via JSON temp files; handle orphaned WireGuard interfaces and stuck processes.
# 1. + require 'json'
# 2. + require_gem 'sys-proctable'
# 3. + current_vpn_info(): Read VPN state from JSON temp file.
# 4. ~ current_wireguard_config_filepath(): Add nil guard for current_vpn_info.
# 5. + write_vpn_info(): Write VPN state (config path and network interface) to temp file.
# 6. ~ unload_wireguard_config(): Add dont_raise: true option for graceful failure.
# 7. ~ up(): Capture network interface name before/after and write to VPN info.
# 8. ~ down(): Check if interface still exists before attempting destroy, add fallback to remove_wireguard_interfaces.
# 9. + remove_wireguard_interfaces(): Clean up WireGuard configs by name, remove state files, kill wireguard-go processes.
# 10. + cleanup_stuck_wg_quick_processes(): Kill stuck wg-quick processes and remove orphaned interfaces.
# 11. + with_lock(): Implement file-based locking to prevent concurrent mercurial runs.
# 12. + pid_exists?(): Check if process is running by PID.
# 13. ~ status(): Add "Not operating" message when VPN is down.
# 14. + output_usage(): Display help text with commands, options, and examples.
# 15. ~ main(): Add 'up' command alias and usage output for no/unknown command.

# Examples:
# 1. `mercurial setup` installs requisite software.
# 2. `mercurial switch` brings up the VPN, if need be, or if already up with swap the current for another different endpoint.
# 3. `mercurial` is the same as `mercurial switch`.
# 4. `mercurial down` brings the VPN down.
# 5. `mercurial switch --dns_servers 1.1.1.1,1.0.0.1` drops, then brings up the VPN with the given DNS servers.
# 6. `mercurial switch --dns_servers 1.1.1.1,1.0.0.1 --retain_endpoint` drops, then brings up the VPN with the given DNS servers without switching endpoints.
# 7. `mercurial switch --config /full/path/to/config.conf`
# 8. `mercurial switch --config ~/config.conf`
# 9. `mercurial switch --config config.conf` assumes the default configs path
# 10. `mercurial switch --config config` will do a partial match in the default path
# 11. `mercurial status` outputs the currently used Wireguard config.

# Notes:
# 1. For automated execution, ensure that /etc/sudoers has an entry like this:
#   thoran    ALL = NOPASSWD: /opt/homebrew/bin/wg-quick *
#   thoran    ALL = NOPASSWD: /bin/kill
# 2. Or, that there's a file /etc/sudoers.d/mercurial with the same kind of entry:
#   thoran    ALL = NOPASSWD: /opt/homebrew/bin/wg-quick *
#   thoran    ALL = NOPASSWD: /bin/kill

require 'json'

require 'Kernel/require_gem'
require_gem 'fileutils'
require_gem 'switches.rb'
require_gem 'sys-proctable'

require 'FileUtils/which'
require 'Kernel/run'
require 'MacOS/IfConfig'
require 'MacOS/VPN'
require 'File/self.grep'

def wg_quick_path
  @wg_quick_path ||= FileUtils.which('wg-quick')
end

def setup
  unless homebrew_installed?
    run('/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"', show: true)
  end
  unless wireguard_tools_installed?
    run('brew install wireguard-tools', show: true)
  end
end

def homebrew_installed?
  FileUtils.which('brew')
end

def wireguard_tools_installed?
  wg_quick_path
end

def check_for_wg_quick_program
  unless wireguard_tools_installed?
    puts "wg-quick was not found.  You must install wireguard-tools (installs wg-quick) first."
    puts "The easist way to install it is by running `mercurial setup`."
    exit
  end
end

def wireguard_config_location
  File.join(%w{~ .config wireguard})
end

def wireguard_configs_path
  File.expand_path(wireguard_config_location)
end

def wireguard_configs_filepaths
  Dir.glob("#{wireguard_configs_path}/*.conf")
end

def wireguard_configs
  wireguard_configs_filepaths.collect{|fp| File.basename(fp)}
end

def random_wireguard_config
  non_current_wireguard_configs = (
    if current_wireguard_config
      (wireguard_configs - [current_wireguard_config])
    else
      wireguard_configs
    end
  )
  non_current_wireguard_configs.sample
end

def random_wireguard_config_filepath
  File.join(wireguard_configs_path, random_wireguard_config)
end

def load_wireguard_config(wireguard_config_filepath)
  run('sudo', wg_quick_path, 'up', wireguard_config_filepath, show: true)
end

def current_vpn_info
  @current_vpn_info ||= (
    if tmpfilename = Dir.glob('/tmp/mercurial-*.tmp').last
      JSON.parse(File.read(tmpfilename))
    end
  )
end

def current_wireguard_config_filepath
  current_vpn_info && current_vpn_info['wireguard_config_filepath']
end

def current_wireguard_config
  File.basename(current_wireguard_config_filepath) if current_wireguard_config_filepath
end

def write_vpn_info(wireguard_config_filepath:, network_interface:)
  vpn_info = {wireguard_config_filepath: wireguard_config_filepath, network_interface: network_interface}
  tmpfile = File.open("/tmp/mercurial-#{Time.now}.tmp", 'w')
  tmpfile.print(JSON.generate(vpn_info))
  tmpfile.close
end

def unload_wireguard_config(wireguard_config_file_path)
  run('sudo', wg_quick_path, 'down', wireguard_config_file_path, show: true, dont_raise: true)
end

def dns_altered_wireguard_config(wireguard_config_filepath, dns_servers)
  config = File.read(wireguard_config_filepath)
  config.gsub(/^DNS = .+$/, "DNS = #{dns_servers.join(', ')}")
end

def write_dns_altered_wireguard_config(wireguard_config_filepath, dns_altered_wireguard_config)
  wireguard_config_filename = File.basename(wireguard_config_filepath)
  FileUtils.mkdir_p('/tmp/wireguard')
  dns_altered_wireguard_config_filepath = "/tmp/wireguard/#{wireguard_config_filename}"
  wireguard_config = File.open(dns_altered_wireguard_config_filepath, 'w', 0o600)
  wireguard_config.puts(dns_altered_wireguard_config)
  wireguard_config.close
  dns_altered_wireguard_config_filepath
end

def up(dns_servers = nil, wireguard_config = nil)
  wireguard_config_filepath = (
    if wireguard_config
      File.join(wireguard_configs_path, wireguard_config)
    else
      random_wireguard_config_filepath
    end
  )
  if dns_servers
    dns_altered_wireguard_config = dns_altered_wireguard_config(wireguard_config_filepath, dns_servers)
    wireguard_config_filepath = write_dns_altered_wireguard_config(wireguard_config_filepath, dns_altered_wireguard_config)
  end

  before = `wg show interfaces`.strip.split
  load_wireguard_config(wireguard_config_filepath)
  after = `wg show interfaces`.strip.split
  network_interface = (after - before).first

  write_vpn_info(wireguard_config_filepath: wireguard_config_filepath, network_interface: network_interface)
end

def down
  if current_vpn_info
    wireguard_config_filepath = current_vpn_info['wireguard_config_filepath']
    unload_wireguard_config(wireguard_config_filepath)
    # Only try to destroy if the interface still exists
    wg_interface = current_vpn_info['network_interface']
    still_exists = `ifconfig #{wg_interface} 2>/dev/null`.strip != ""
    if still_exists
      puts "Interface still exists, forcefully destroying: #{wg_interface}..."
      MacOS::IfConfig.destroy_interface(wg_interface)
    end
  else
    remove_wireguard_interfaces
  end
  Dir.glob('/tmp/mercurial-*.tmp').each{|filename| FileUtils.rm(filename)}
  Dir.glob('/tmp/wireguard/*.conf').each{|filename| FileUtils.rm(filename)}
end

def switch(dns_servers = nil, config: nil, retain_endpoint: false)
  check_for_wg_quick_program
  cleanup_stuck_wg_quick_processes
  with_lock do
    if up?
      if retain_endpoint
        wireguard_config = current_wireguard_config
      end
      down
    end
    if config
      wireguard_config = (
        if config =~ /\//
          if File.exist?(config)
            File.basename(config)
          else
            puts "#{config} not found."
            exit
          end
        else
          candidate_config = File.join(wireguard_configs_path, config)
          if File.exist?(candidate_config)
            config
          else
            File.basename(wireguard_configs_filepaths.detect{|filepath| File.basename(filepath) =~ /#{config}/i})
          end
        end
      )
    end
    up(dns_servers, wireguard_config)
  end
end

def status
  if current_wireguard_config_filepath
    puts current_wireguard_config_filepath
    puts File.grep(current_wireguard_config_filepath, /DNS/)
  else
    puts "Not operating."
  end
end

def up?
  MacOS::VPN.up?
end

def remove_wireguard_interfaces
  # Try to get WireGuard config names from runtime directory
  config_names = Dir.glob('/var/run/wireguard/*.name').map{|f| File.basename(f, '.name')}

  if config_names.any?
    config_names.each do |config_name|
      puts "Removing WireGuard interface: #{config_name}..."
      system("sudo #{wg_quick_path} down #{config_name} 2>/dev/null")
    end
  end

  # Force cleanup of any remaining WireGuard state
  puts "Cleaning up WireGuard state files..."
  system("sudo rm -f /var/run/wireguard/*.sock 2>/dev/null")
  system("sudo rm -f /var/run/wireguard/*.name 2>/dev/null")

  # Kill any lingering wireguard-go processes
  system("sudo pkill -9 wireguard-go 2>/dev/null")

  sleep 2
end

def cleanup_stuck_wg_quick_processes
  # Kill stuck wg-quick processes.
  Sys::ProcTable.ps.select{|p| p.comm =~ /wg-quick/}.each do |proc|
    puts "Killing wg-quick process: #{proc.pid}..."
    run("sudo kill -9 #{proc.pid}", show: true, dont_raise: true)
  end
  remove_wireguard_interfaces
end

def with_lock
  lockfile = '/tmp/mercurial.lock'
  if File.exist?(lockfile)
    lock_age = Time.now - File.mtime(lockfile)
    if lock_age > 300 # If older than 5 minutes, then the lock is stale.
      puts "Removing stale lock file (#{lock_age.to_i}s old)"
      File.delete(lockfile)
    else
      if pid_exists?(lockfile)
        raise "mercurial is already running, exiting."
      else # The process is dead, so remove stale lock.
        File.delete(lockfile)
      end
    end
  end
  File.write(lockfile, Process.pid)
  begin
    yield
  ensure
    File.delete(lockfile) if File.exist?(lockfile) && File.read(lockfile).to_i == Process.pid
  end
end

def pid_exists?(lockfile)
  pid = File.read(lockfile).to_i
  !`ps -p #{pid} -o pid=`.strip.empty?
end

def switches
  @switches ||= (
    Switches.new do |s|
      s.set :d, :dns, :dns_servers
      s.set :c, :config
      s.set :r?, :retain?, :retain_endpoint?
    end
  )
end

def dns_servers
  switches.dns_servers&.split(',')
end

def output_usage
  puts "Usage: mercurial <command> [options]"
  puts
  puts "Commands:"
  puts "  setup                          Install wireguard-tools"
  puts "  up [options]                   Bring up VPN (alias for switch)"
  puts "  down                           Bring down VPN if running"
  puts "  switch [options]               Bring up VPN or switch VPN endpoint/DNS"
  puts "  status                         Show current VPN configuration"
  puts
  puts "Options:"
  puts "  -d, --dns, --dns_servers SERVERS"
  puts "      Comma-separated DNS servers (e.g., 1.1.1.1,1.0.0.1)"
  puts "  -c, --config CONFIG"
  puts "      Config file (path, name, or partial match)"
  puts "  -r, --retain, --retain_endpoint"
  puts "      Keep current endpoint when switching DNS"
  puts
  puts "Examples:"
  puts "  mercurial switch"
  puts "  mercurial switch --dns_servers 1.1.1.1,1.0.0.1"
  puts "  mercurial switch --config AU.vpn.mega.nz.conf"
  puts "  mercurial switch --dns_servers 1.1.1.1,1.0.0.1 --retain_endpoint"
end

def main
  switches
  case ARGV[0]
  when 'setup'; setup
  when 'down'; down if up?
  when 'switch'; switch(dns_servers, config: switches.config, retain_endpoint: switches.retain_endpoint?)
  when 'status'; status
  when 'up'; switch(dns_servers, config: switches.config, retain_endpoint: switches.retain_endpoint?)
  else
    output_usage
    exit 1
  end
end

main
